State Management Complexity
	•	Overlapping State: The app maintains similar information in multiple places. For example, the Document and EditorState each carry a version counter ￼ ￼ to signal changes, and both structures hold state that affects rendering. This duplication complicates synchronization. Suggestion: Consolidate what you can. Rely on a single source of truth for change tracking – e.g. use the Document.version alone for invalidation (since most edits ultimately alter the document). If UI-only state needs tracking (like selection changes), integrate it with the document’s version or use a combined “dirty” flag. Reducing parallel state makes it clearer when something actually changed.
	•	Active Tool Handling: Currently the active tool is stored as an Option<Arc<ToolType>> inside EditorState ￼, updated via a clone-on-write builder pattern, and the app keeps a separate list of tools to choose from ￼. This is overly complex. Suggestion: Simplify to one authoritative tool state. For instance, keep a single active_tool_index or an enum for the current tool mode. You can instantiate each tool once and store them (so their configuration persists), switching by reference rather than cloning new tools on each swap. This removes the need for Arc in EditorState and the builder indirection – the UI can just call methods on the currently active tool object.
	•	Selection State Duplication: The selection is tracked in multiple forms. EditorState holds a set of selected element IDs ￼, but the SelectionTool also manages its own SelectionState (Idle, Dragging, Resizing, etc.) and preview of the selected item ￼ ￼. There’s even an attempt at an EditorState::selected_element() that just logs a warning (not truly implemented) ￼. Suggestion: Have a single system of record for what’s selected. The simplest route is to let EditorState (or a merged Document state) own the selection IDs and provide helper methods to get actual elements. The Selection tool can then just read from and modify that state (e.g. by issuing a command or calling a function to update selection). This way, you don’t have to keep an ID set in one place and a SelectionState enum in another perfectly in sync – the duplication can be eliminated or minimized (for example, the tool’s internal state might still track a drag in progress, but it would rely on EditorState for the base selection). If merging modules, you might even fold selected_element_ids into Document itself for one-stop state access.
	•	Scattered Resize/Drag Flags: Transient UI state like an ongoing resize is tracked in multiple places right now – e.g. PaintApp.processing_resize and stored last_resize_preview/last_active_corner ￼, as well as flags inside Renderer (which has its own resize_preview field) and the SelectionTool’s state. This makes it hard to follow the logic of a drag/resize operation because different pieces of code check or set different flags. Suggestion: Consolidate the handling of these transient states. One approach is to let the SelectionTool manage the entire resize/drag process: it can record the active corner and preview rect in its state and update the Renderer as needed for drawing, instead of funneling that info back into the main app. The main loop can simply detect “if tool is in a resizing state and mouse released, finalize the command.” By keeping the knowledge of an active resize mostly in one place (the tool/renderer), you remove the need for the core app to shuttle around last_active_corner or processing_resize. In short, each piece of state (current tool, current selection, current drag/resize action) should have a single owner responsible for updating it, while others read it as needed.

Strokes vs. Images Unification
	•	Duplicated Logic: The code treats strokes and images as separate categories, leading to a lot of repetition. The Document holds them in separate lists (strokes vs images) with nearly identical methods for adding, removing, and finding elements of each type ￼ ￼. Many routines have to loop over both lists or handle two code paths – for example, hit-testing checks every stroke, then every image ￼ ￼. Suggestion: Merge these into a single abstraction for “drawable elements.” You could have Document maintain one Vec<ElementType> (using the existing enum that wraps a Stroke or Image) ￼. This way, adding a new element is one method (add_element) instead of two, and iterating over all content becomes a single loop. Functions like find_by_id or collision detection would naturally handle both kinds uniformly, which cuts down on boilerplate and the chance of inconsistent behavior between strokes vs images.
	•	Unified Data Structure: Converging strokes and images into one list may require a bit of rethinking of how you reference them, but it simplifies state significantly. Both Stroke and Image already share some common traits (an ID, a bounding rectangle, the ability to move/resize via commands). Suggestion: Leverage the ElementType enum or implement a trait for common element behaviors (e.g., each element can report its id(), rect(), and perhaps a draw method). By storing a vector of trait objects or the enum, the document can manage all elements in one structure. This would allow you to remove methods like Document::find_stroke_by_id and replace them with a single find_element_by_id that doesn’t need to know the element’s type ahead of time ￼. The code becomes easier to extend – if tomorrow you add a new element type (say, text), you don’t need to add a whole parallel set of lists and functions.
	•	Rendering & Transformations: Right now, the rendering code and transformation commands have to account for the two types separately. For instance, resizing an image vs. a stroke takes very different code paths: the Image case computes new pixel data or inserts a placeholder ￼, while the Stroke case recalculates points or falls back to creating a new stroke ￼ ￼. There’s duplicate logic to handle each in commands and preview drawing. Suggestion: Move toward a unified representation when possible. An ambitious approach is to treat everything as a texture/bitmap on the canvas – e.g. render strokes into an offscreen image or GPU texture, so that moving or scaling any element (stroke or photo) uses the same texture transformation pipeline. This would simplify the renderer since every element could be drawn via the same mechanism (blitting a texture) rather than mixing egui shape draws with texture draws. The trade-off here is that you lose the infinite resolution of vector strokes and potentially waste memory on rasterizing strokes. If keeping strokes vector is important, the alternative is to at least unify the interfaces: provide a common function like element.draw(painter) that internally does match { Stroke => draw_stroke(...), Image => draw_image(...) }. That way, the higher-level code doesn’t need two separate loops – it just iterates over all elements and calls draw. You’ve already started this with the ElementType enum and helper methods; pushing it further by unifying the storage and draw calls will reduce special cases.
	•	Layer Ordering: Managing z-order is easier when all elements are in one list. The current design implicitly might be drawing strokes and images in separate passes (the hit-testing checks strokes first then images ￼ ￼, and it’s likely the rendering does something similar). This could cause odd stacking (e.g. maybe all images always appear on top of all strokes, regardless of addition order). Suggestion: Once you have a unified element list, you can determine draw order explicitly by the order in that list or an associated z-index. For example, the newest element could simply be top-most, or you could expose “bring to front/back” operations that adjust the order in the list. By doing so, you eliminate the hardcoded notion that one type draws above the other. This not only fixes potential visual bugs but also removes the need for type-based ordering logic. In a unified setup, Document.elements could be drawn in sequence and you’d naturally intermix strokes and images according to their intended layering.

Command System Improvements
	•	Simplify Command Variants: The current Command enum differentiates between element types, which leads to duplicated logic. For instance, there’s AddStroke(StrokeRef) vs AddImage(ImageRef) and separate handling for each ￼ ￼. If strokes and images are unified as suggested, you can merge those into a single AddElement(ElementType) command. Suggestion: Refactor the command system such that commands operate on the abstract element level. An AddElement could carry an ElementType (or perhaps a trait object) and the apply/undo logic would be the same regardless of it being a stroke or image. This reduces boilerplate and makes the command list extensible (new element types wouldn’t require a new enum variant if they all fit under AddElement). The code to execute or undo an addition would not need to branch on type at all – it would just add or remove that element from the document.
	•	Consolidate Transform Commands: Similarly, MoveElement and ResizeElement commands store an element ID and sometimes an original_element for undo ￼. There’s logic to handle images vs strokes differently inside Command::apply() for resize (e.g. creating a new Image vs mutating a Stroke) ￼ ￼. While some of this is inevitable due to the content differences, you can streamline it. Suggestion: Ensure each command carries all data needed to both apply and unapply it without extra lookups. For example, when creating a ResizeElement command, capture the element’s original state (perhaps store an ElementType snapshot in the command). The command’s apply can then replace or transform the element, and unapply can restore from that saved original. This is already partly done with the original_element field; just make it standard for any command that changes existing elements. It simplifies undo/redo and will be useful if you move to a non-destructive model (since each command knows its before/after).
	•	Prepare for Non-Destructive Editing: The ultimate goal of a graph-based, non-destructive command structure would be to stop treating commands as one-time modifications and start treating them as a list of operations that derive the current document state. Right now, applying a command mutates the Document directly and the history is only used for undo/redo. Suggestion: Transition toward an intent-based command model. Instead of immediately doing document.add_stroke() on an AddStroke command, you could record that intent in a list (the “edit graph”). The document’s drawing could then be regenerated from scratch by replaying all commands in sequence. This would open the door to more advanced features: you could allow toggling a command on/off, reordering operations, or parameterizing them (think of commands as nodes in a procedural graph that produces the final image). Implementing a full graph now is a big leap, but you can start laying groundwork: for instance, keep the list of all commands and have the renderer use that to redraw, rather than relying on the document’s stored strokes/images alone. Even if you still mutate the Document for now, structuring code to also work from a command list will make a future pivot to a pure non-destructive pipeline easier.
	•	Command Structure and Extensibility: To facilitate a graph, commands might need to be more generic or have a common interface. Currently, Command is an enum with specific variants and apply/unapply methods. In a more flexible system, you might have a trait CommandTrait with something like fn execute(old_doc: &Document) -> Document (returning a new document or new element state). That could allow you to compose commands functionally. Suggestion (long-term): Consider a redesign where the Document is not mutated in place at all; instead, each command produces a new version or new element, and you store references to the whole chain. This is akin to an event sourcing approach. The trade-off is complexity and performance (recomputing on the fly), but it gives ultimate flexibility for non-destructive editing. As an intermediate step, your current Command system can be refactored to be more data-driven (focus on describing what to do, not how to do it in place). For example, a ResizeElement command could store: “element X, original bounds Y, new bounds Z, original pixel data (if any)” and knows how to apply or reverse that. Later, that could become a node in a graph where Y -> Z is a transform applied to element X’s data. In summary, start making commands self-contained and generic where possible – this will pay off when evolving the architecture.
	•	Include All Edits in History (or Not): One inconsistency to note is that some user actions aren’t represented in the command system at all (selection changes, for instance, are done directly in state with no Command) ￼. This might be fine (you might not want selection to clutter undo history), but it’s worth deciding explicitly. Suggestion: If selection and similar ephemeral actions should remain outside the command system, ensure the code handling them is clearly separated from command logic. Conversely, if you want everything to be undoable, then introducing commands like SelectElement or ChangeTool would be needed. In the current code, selection is cleared or set directly in EditorState when tools change ￼. For simplicity, it’s often okay to treat that as UI state (not part of the undoable document state). Just document that decision and manage selection in one place as mentioned earlier, so it doesn’t conflict with command-based edits.

Module Mergers and Restructuring
	•	Merge Document and EditorState: Given how intertwined these are, combining them could reduce complexity. The EditorState (besides versioning) mainly holds the active tool and selected IDs ￼, which could be considered part of the overall document state in an editing context. You could merge these into a single DocumentState struct that has both the content (strokes, images) and the UI state (selection, current tool) together. Suggestion: Try folding EditorState into Document, or at least into the main PaintApp state, to avoid passing both around. For example, when handling an event or rendering, you currently juggle document and state – if it were one object, methods could naturally handle both content and selection. The trade-off is a slight loss of separation between model and UI, but if the app isn’t intended to have a headless/core vs UI split, merging them streamlines development. In practice, it might mean moving fields like selected_element_ids and active_tool into Document (or renaming Document to something like EditorModel that encompasses all state). This way, versioning is unified and there’s no need to update two structures in parallel.
	•	Renderer and Central Panel: The division between the Renderer and the CentralPanel drawing code is a bit unclear and could be simplified. The CentralPanel (canvas) code is directly drawing strokes (using the egui painter) and handling interactions like selection outlines, while the Renderer is managing OpenGL textures for images and some preview state ￼ ￼. There’s overlap in responsibility – both know about things like the resize preview. Suggestion: Either make the Renderer solely responsible for all drawing, or collapse the Renderer into the UI code if it’s not doing much beyond helping egui draw images. For example, you could have the CentralPanel call a single renderer.draw_document(document, selection) function, and inside that, the renderer goes through elements and handles both vector and image drawing (using egui’s painter or low-level as needed). This would centralize rendering logic instead of splitting it. On the flip side, if the Renderer exists to abstract away GPU details, then push more of the drawing logic into it – let it provide high-level calls like renderer.draw_element(element, is_selected) and keep egui-specific code out of the panel. Either approach can work; the key is to reduce the ping-pong between modules. Merging them means one less piece of state (Renderer has its own caches and frame counter) to coordinate with the main app. If, for instance, you always call renderer functions at draw time, you might not even need to store resize_preview in both Renderer and SelectionTool – it could live in one place.
	•	Input Handling Streamlining: The code uses an InputHandler and a route_event function to funnel events into the right place ￼. This indirection adds complexity, as seen by the many parameters passed to route_event. If the event routing isn’t doing anything more than what the active tool or some common shortcuts require, you can simplify it. Suggestion: Remove the InputHandler/route_event abstraction and handle events in the main update loop or directly in egui callbacks. For example, you might check if active_tool == Some(tool), then call tool.on_pointer_down(pos, doc, state) directly instead of packing an event and routing it. Egui lets you access input events each frame; you could integrate that with your command invocation more directly. The benefit is that it’s easier to follow the flow: “user clicks -> go to active tool logic -> maybe produce a Command -> apply it” all in one place. If you have complex mappings (like keyboard shortcuts that trigger commands), those can still be handled in a straightforward match instead of a separate router module. In short, consider collapsing InputHandler into PaintApp to cut down on the number of moving parts.
	•	FileHandler Integration: Similar to input, the file drop logic (loading an image from disk and adding it) is fairly self-contained and doesn’t necessarily need its own object. The FileHandler currently collects dropped files and then the app uses it to create commands for adding images. You might merge this functionality into the main app or the document as well. Suggestion: One way is to have a method like Document::handle_file_drop(data) -> Command which constructs an AddImage command. This would localize the file-to-image conversion without a whole FileHandler struct. If the FileHandler’s sole job is to bridge egui’s dropped file events into your command system, merging it will simplify the control flow (you can go from an egui file drop event directly to a new image in the document). The trade-off is losing a bit of isolation for file I/O, but since this isn’t a large or security-critical piece, collapsing it into the main loop or document module is reasonable.
	•	General Module Pruning: Review if any other modules are providing minimal benefit due to the project’s size. For example, if the panels::tools_panel module just creates some buttons for tool selection, it could potentially be merged with other UI code. The idea isn’t to put everything in one file, but to make sure each separation is pulling its weight. Right now, core modules like document.rs and state.rs have intertwined purposes, so merging those might give the biggest simplification. Focus on combining those high-level modules first before worrying about minor ones.

General Simplifications and Cleanups
	•	Remove Over-Engineering (Arc & Builder Pattern): The use of Arc and the clone-on-write EditorStateBuilder is an over-complication in this context. Since the UI runs on a single thread, you can safely use simple mutable structures. For instance, instead of storing EditorState.shared: Arc<EditorStateData> and making every change by cloning it ￼, just use EditorStateData directly as a mutably borrowed struct. Rust’s ownership can handle this since you’re typically not sharing state across threads. Suggestion: Refactor EditorState to drop the Arc – keep an owned EditorStateData inside it (or eliminate the wrapper entirely). Updates to active tool or selection can be plain methods that modify the fields. This will greatly simplify the code for setting tools or selections (no need for .builder().with_selected...().build() chaining). The trade-off (losing immutability guarantees from Arc) isn’t a real issue here, because you control all accesses to EditorState anyway in the single-threaded GUI loop. Simpler code will outweigh any theoretical benefits of the current pattern.
	•	Avoid Unnecessary Reference Counting: Expanding on the above, strokes and images are also stored as Arc (e.g. StrokeRef = Arc<Stroke>) ￼. The rationale was probably to share them between the document and things like the undo commands or previews. However, if you adopt a design where the Document is the single owner of elements and commands carry their own saved copies for undo, you don’t need every element to be atomically reference-counted. Suggestion: You could store strokes and images as plain values or behind Rc<…> (non-atomic) if you still want shared ownership without thread safety overhead. For example, if a selection preview needs to hold a stroke temporarily, it could clone the stroke data or use a lightweight Rc. By removing Arc where it isn’t critical, you simplify memory management and make the borrowing semantics clearer (Arc can obscure who mutates what, as seen with the tricky Arc::get_mut checks in the code ￼). In summary, use owned data and clone it when needed for undo/redo or previews, rather than trying to share everything via Arc. It will reduce the risk of Arc-related bugs (like failing to get a mutable reference due to extra clones hanging around).
	•	Consistency in Undo/Redo Design: Decide which operations should be undoable and enforce a consistent pattern. As noted, the selection changes are done outside the command system ￼, and tool switches also just directly mutate state. That’s fine as long as you consider those actions part of the UI state rather than the document state. To avoid confusion, clearly separate “document-editing” commands from “view/editor state” updates. Suggestion: Perhaps maintain two layers of state: the document (which is fully covered by the command history for undo/redo), and the session state (current tool, current selection, canvas zoom, etc.) which isn’t in the undo stack. Then enforce that all document modifications (anything that changes strokes, images, their properties) goes through a Command. This way, undo/redo will never surprise you by missing an edit. Meanwhile, things like selection can be changed freely without polluting the history. Document this distinction and make it clear in code (for example, by not mixing selection updates inside command apply logic – handle them separately). This separation will also make a future non-destructive graph easier, since that likely concerns document content ops only.
	•	Streamline Data Flow for Actions: Try to handle each user action (e.g. a drag, a resize, a draw) in as linear and localized a way as possible. The current flow can be a bit convoluted – e.g., a resize involves the SelectionTool setting a preview, the Renderer storing a preview rect, the PaintApp noticing when to finalize the resize, and the Command actually doing the replace in the Document ￼ ￼ ￼. You can simplify this by reducing how many components need to talk to each other. Suggestion: For instance, when a resize drag is finished, the SelectionTool could directly create a ResizeElement command (with the final corner and position) and return it. The main app then just executes that command. All the interim preview drawing can be internal to the tool/renderer and doesn’t need to set persistent flags in the app state. By designing interactions so that one part of the code “owns” the process (the tool in this case) and produces a final result (the Command), you eliminate a lot of cross-module coordination. This makes the state changes easier to reason about – you know exactly where a given variable is modified.
	•	Eliminate Dead Code and TODOs: Cleaning up unused or unfinished code will reduce mental overhead. In the current codebase, some methods are left as stubs (e.g., EditorState::selected_elements() just logs a warning and returns an empty vector ￼). These can confuse developers (is it a bug or just not implemented?). Suggestion: Either implement these properly or remove them until you’re ready to implement. In the case of selected_elements(), since you plan to find selected elements via Document lookups, you could implement it to do that (iterate over selected IDs and call Document::find_element_by_id for each). If that’s not needed now, it’s better to delete the unused function to keep the codebase lean. Similarly, double-check for any layering in abstractions that isn’t buying much – for example, if the ToolConfig trait and separate config structs aren’t actually making it easier to preserve tool settings (since you recreate tools on each selection currently), you could simplify tools by just storing their settings in the tool struct and dropping the config trait until you truly need to save/restore configurations. The guiding principle is: remove any abstraction, state, or code path that isn’t pulling its weight. A smaller, cleaner codebase is always easier to refine into a better architecture.

By addressing these areas – simplifying state management, unifying how different element types are handled, refining the command architecture, merging redundant modules, and cleaning up abstractions – the codebase will become easier to understand and extend. Each suggestion comes with trade-offs (e.g. merging structures might reduce modularity, unifying strokes and images might sacrifice some ideal vector handling), so consider which simplifications provide the most benefit for the complexity they remove. The overall goal is to have a clear, single source of truth for each piece of state and a straightforward flow of data from user actions to application state changes.

Order of events:
	1.	Consolidate State Management: Merge Document and EditorState, eliminate duplicate versioning and selection tracking. One source of truth makes reasoning and future changes (like non-destructive edits) simpler.
	2.	Unify Element Representation: Merge strokes and images into a single element type. This cuts down duplicated logic and streamlines rendering, hit-testing, and transformations.
	3.	Simplify Command System: Refactor commands to operate on unified elements and store self-contained state. It reduces fragmentation and eases the move to a graph-based non-destructive model.
	4.	Streamline UI & Input Handling: Simplify event routing and transient state (e.g. resize/drag flags) so that each tool manages its own process with minimal cross-module communication.
	5.	Remove Over-Engineering: Drop unnecessary use of Arc and clone-on-write patterns in favor of direct, mutable state since you’re in a single-threaded GUI context.
	6.	General Cleanups: Remove dead code and clarify separation between document commands and ephemeral UI state to reduce mental overhead.
